#!/usr/bin/env python2
# -*- backup-inhibited: true; encoding: utf-8 -*-
#
# oveja eléctrica
# copyright (c) 2003-2017 santiago peresón <yaco@yaco.net>
# http://yaco.net/oe/
#
# this file is part of 'oe3', which is released under the gnu general public
# license, version 3. see LICENSE for full license details.
#
# TO-DO:
#   + use wcwidth to calculate paddings
#   + extend monitorin to all modules
#   + add oe3:afol graph with blinkenlichts
#   - decide and fix reduxes on transp terms
#   - argparse, usage
#
# DONE:
#   x check argv, default to var/state/currestim
#   x one redux > curses-redux
#   x read .json
#   x show pretty reduxes
#   x add last mod date at bottom right
#   x port time functions to arrow
#   x add data (id, name) at top right
#   x generate layout (check viewport size!)
#   x show spectrofoto choices
#   x replace \x1b[38;5;19m and friends with _setf(), _setb(), _scp(), _sgr0()
#   x mod coag_add_ice, oe3 and spectrofoto.py to update state files
#   x rewrite to use comp and interp run/ state files
#

"""statewatch
internal oe3 state watcher for voe3t

usage: bin/statewatch
"""


from __future__ import division, print_function, unicode_literals

__version__ = '0.1.0'

import curses
import json
import logging
import os
import sys
import time
from os.path import exists, getmtime

import arrow

sys.path.append(os.path.abspath(os.path.dirname(__file__) + '/../lib'))
from oe3 import utils
from oe3.comp.spectrofoto import pformat_choices

_log  = logging.getLogger('voe3t')
_conf = {}

def main(argv = sys.argv):
  """read module states and display them graphically"""

  global _cols, _conf

  # get terminal size
  # XXX py3k: replace with os.get_terminal_size!
  curses.setupterm()
  _cols  = curses.tigetnum('cols')

  # init
  _conf   = utils.load_json('etc/voe3t.json')
  modules = _conf['watched_modules']; modules.reverse()
  checks  = {m: arrow.get(0) for m in modules}
  dirty   = True
  _log.info("oe3 state watcher initialized")

  # main loop
  try:
    while True:

      # find runfile
      running = None
      for module in modules:
        if exists('run/{}.json'.format(module)):
          path = 'run/{}.json'.format(module)
          running = module
          break

      if running is None:
        if dirty:
          _log.debug("   nothing happening, clearing viewer...")
          os.system('clear')
          _print_clear()
          dirty = False
      elif arrow.get(getmtime(path)) > checks[running]:
        dict_ = utils.load_json(path)
        #_log.debug("   runfile {} for '{}' updated: {}% done".format(
        #  path, module, dict_['progress']))
        checks[module] = arrow.now()
        os.system('clear')
        eval("_print_{module}(dict_)".format(module=module))
        dirty = True

      time.sleep(0.1)

  except KeyboardInterrupt:
    print(); exit(130)


def _print_clear():
  """clear the viewer"""

  print("\n\n\n\n\n\n{}{:^{}}{}\n\n\n\n".format(
    _setf(19),
    "⎡oe3 not running⎦", _cols,
    _sgr0()
  ))


def _print_comp(dict_):
  """print comp state: song meta, estim reduxes, choices, progress"""

  reduxes = [dict_['reduxes'][img] for img in dict_['images']]
  _print_comp_header(dict_)
  _print_reduxes(reduxes[:51])  # XXX to-do: decide how to show bigger colls
  _print_comp_footer(dict_)
  _print_progress(dict_['progress'])
  sys.stdout.flush()


def _print_interp(dict_):
  """print interp state: song meta, estim reduxes, choices, fake progress"""

  reduxes = [dict_['reduxes'][img] for img in dict_['images']]
  dur     = int(dict_['duration'])
  for i in xrange(dur + 1):
    _print_interp_header(dict_)
    _print_reduxes(reduxes[:51])  # XXX to-do: decide how to show bigger colls
    _print_comp_footer(dict_)
    _print_progress(min(i * 100 / dur, 100))
    sys.stdout.flush()
    time.sleep(0.75)
  while exists('run/interp.son'): time.sleep(0.1)


def _print_comp_header(dict_):
  """print song metadata"""

  header = "{subcomp} · {estim_name} ⎡{estim_id}⎦".format(
    subcomp    = dict_['comp'][0].lower(),
    estim_name = dict_['estim_name'],
    estim_id   = dict_['estim_id']
  )
  print("{}{:^{}}{}".format(_setf(19), header, _cols, _sgr0()))


def _print_comp_footer(dict_):
  """print pretty comp choices"""

  if 'choices' in dict_:
    choice_l = pformat_choices(dict_['choices'], joined=False)
    termed   = ''
    for choice in choice_l:
      tmp, cert = choice.split('.')
      asp, val  = tmp.split(':')
      termed += (asp + ':' + (_setf(21) if int(cert) > 50 else ''))
      termed += val + (_setf(19) if int(cert) > 50 else '') + ' '
    width   = 87  # 11 choices * (7 chars + space) - 1 space

  else:
    termed = "‹nochoices›"
    width  = 11

  print('\n' + ' ' * ((_cols - width) // 2) + _setf(19) + termed + _sgr0())


def _print_interp_header(dict_):
  """print song metadata"""

  header = "{subcomp} · {song} ⎡{estim}⎦ · {duration}".format(
    subcomp  = dict_['comp'][0].lower(),
    song     = dict_['id'],
    estim    = dict_['estim_name'],
    duration = utils.secs2mmss(dict_['duration']).strip()
  )
  print("{}{:^{}}{}".format(_setf(19), header, _cols, _sgr0()))


def _print_progress(prog):
  """print progress bar"""

  # '  [<bar><pad>]  '
  width  = _cols - 6
  filled = int(prog * width / 100)
  pad    = ' ' * (width - filled) + _setf(21)
  if filled > width - 1:
    bar = '─' * filled + pad
  else:
    bar = '{}{}─{}─{}─{}'.format(
      '─' * (filled - 3), _setf(19), _setf(18), _setf(17), pad)
  print("  {}⎡{}⎦{} ".format(_setf(21), bar, _sgr0()), end='')


def _print_reduxes(reduxes):
  """show pretty reduxes"""

  len_reduxes = len(reduxes)
  if len_reduxes < 11:
    print('\n\n')               # three lines
    _print_redux_line(reduxes)
    print('\n\n')               # three lines
  elif len_reduxes < 29:
    half = -(-len_reduxes // 2)
    print()
    _print_redux_line(reduxes[:half])
    print()
    _print_redux_line(reduxes[half:])
    print()
  else:
    one_3rd  = -(-len_reduxes // 3)
    two_3rds = one_3rd * 2
    _print_redux_line(reduxes[:one_3rd])
    _print_redux_line(reduxes[one_3rd : two_3rds])
    _print_redux_line(reduxes[two_3rds:])


def _print_redux_line(reduxes, end='\n'):
  """print one line of formatted reduxes"""

  rcurses     = map(_redux2term, reduxes)
  rcurses_zip = zip(*rcurses)

  lpad = ' ' * ((_cols - (len(reduxes) * 6 - 1)) // 2)
  print(lpad, ('\n' + lpad).join([" ".join(l) for l in rcurses_zip]),
        sep='', end=end)


def _redux2term(redux):
  """generate a three-tuple of 5-char strings for screen printing"""

  rlines = ["00000"] + [redux[i:i+5] for i in range(0, len(redux), 5)]
  return ["".join(map(_tup2term, rlines[0], rlines[1])) + _sgr0(),
          "".join(map(_tup2term, rlines[2], rlines[3])) + _sgr0(),
          "".join(map(_tup2term, rlines[4], rlines[5])) + _sgr0()]


def _tup2term(top, bot):
  """char tuple to term sequence"""

  return "{}{}▄".format(
    "\x1b[48;5;{}m".format(int(top) + 16),
    "\x1b[38;5;{}m".format(int(bot) + 16)
  )


# term color functions
def _setf(color): return "\x1b[38;5;{}m".format(color)
def _setb(color): return "\x1b[48;5;{}m".format(color)
def _sgr0():      return "\x1b[0m"

if __name__ == "__main__":
  try:
    exit(main(sys.argv))
  except KeyboardInterrupt:
    print(); exit(130)
